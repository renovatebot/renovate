import type { PackageRule, RenovateConfig } from '../../../config/types';
import { NO_VULNERABILITY_ALERTS } from '../../../constants/error-messages';
import * as datasourceMaven from '../../../datasource/maven';
import { id as npmId } from '../../../datasource/npm';
import * as datasourceNuget from '../../../datasource/nuget';
import { PypiDatasource } from '../../../datasource/pypi';
import { RubyGemsDatasource } from '../../../datasource/rubygems';
import { logger } from '../../../logger';
import { platform } from '../../../platform';
import { SecurityAdvisory } from '../../../types';
import { sanitizeMarkdown } from '../../../util/markdown';
import { regEx } from '../../../util/regex';
import * as allVersioning from '../../../versioning';
import * as mavenVersioning from '../../../versioning/maven';
import * as npmVersioning from '../../../versioning/npm';
import * as pep440Versioning from '../../../versioning/pep440';
import * as rubyVersioning from '../../../versioning/ruby';
import * as semverVersioning from '../../../versioning/semver';

type Datasource = string;
type DependencyName = string;
type FileName = string;
type VulnerableRequirements = string;

type CombinedAlert = Record<
  FileName,
  Record<
    Datasource,
    Record<
      DependencyName,
      Record<
        VulnerableRequirements,
        {
          advisories: SecurityAdvisory[];
          fileType?: string;
          firstPatchedVersion?: string;
        }
      >
    >
  >
>;

export async function detectVulnerabilityAlerts(
  input: RenovateConfig
): Promise<RenovateConfig> {
  if (!input?.vulnerabilityAlerts) {
    return input;
  }
  if (input.vulnerabilityAlerts.enabled === false) {
    logger.debug('Vulnerability alerts are disabled');
    return input;
  }
  const alerts = await platform.getVulnerabilityAlerts();
  if (!alerts.length) {
    logger.debug('No vulnerability alerts found');
    if (input.vulnerabilityAlertsOnly) {
      throw new Error(NO_VULNERABILITY_ALERTS);
    }
    return input;
  }
  const config = { ...input };
  const versionings: Record<string, string> = {
    maven: mavenVersioning.id,
    npm: npmVersioning.id,
    nuget: semverVersioning.id,
    pypi: pep440Versioning.id,
    rubygems: rubyVersioning.id,
  };
  const combinedAlerts: CombinedAlert = {};
  for (const alert of alerts) {
    if (
      alert.securityVulnerability?.package?.name === 'yargs-parser' &&
      (alert.vulnerableRequirements === '= 5.0.0-security.0' ||
        alert.vulnerableRequirements === '= 5.0.1')
    ) {
      continue;
    }
    try {
      if (alert.dismissReason) {
        continue;
      }
      if (!alert.securityVulnerability.firstPatchedVersion) {
        logger.debug(
          { alert },
          'Vulnerability alert has no firstPatchedVersion - skipping'
        );
        continue;
      }
      const datasourceMapping: Record<string, string> = {
        MAVEN: datasourceMaven.id,
        NPM: npmId,
        NUGET: datasourceNuget.id,
        PIP: PypiDatasource.id,
        RUBYGEMS: RubyGemsDatasource.id,
      };
      const datasource =
        datasourceMapping[alert.securityVulnerability.package.ecosystem];
      const depName = alert.securityVulnerability.package.name;
      const fileName = alert.vulnerableManifestPath;
      const fileType = alert.vulnerableManifestFilename;
      const firstPatchedVersion =
        alert.securityVulnerability.firstPatchedVersion.identifier;
      const advisory = alert.securityAdvisory;
      let { vulnerableRequirements } = alert;
      // istanbul ignore if
      if (!vulnerableRequirements.length) {
        if (datasource === datasourceMaven.id) {
          vulnerableRequirements = `(,${firstPatchedVersion})`;
        } else {
          vulnerableRequirements = `< ${firstPatchedVersion}`;
        }
      }
      if (datasource === PypiDatasource.id) {
        vulnerableRequirements = vulnerableRequirements.replace(
          regEx(/^= /),
          '== '
        );
      }
      combinedAlerts[fileName] ||= {};
      combinedAlerts[fileName][datasource] ||= {};
      combinedAlerts[fileName][datasource][depName] ||= {};
      combinedAlerts[fileName][datasource][depName][vulnerableRequirements] ||=
        {
          advisories: [],
        };
      const alertDetails =
        combinedAlerts[fileName][datasource][depName][vulnerableRequirements];
      alertDetails.advisories.push(advisory);
      const version = allVersioning.get(versionings[datasource]);
      if (version.isVersion(firstPatchedVersion)) {
        if (
          !alertDetails.firstPatchedVersion ||
          version.isGreaterThan(
            firstPatchedVersion,
            alertDetails.firstPatchedVersion
          )
        ) {
          alertDetails.firstPatchedVersion = firstPatchedVersion;
        }
      } else {
        logger.debug('Invalid firstPatchedVersion: ' + firstPatchedVersion);
      }
      alertDetails.fileType = fileType;
    } catch (err) {
      logger.warn({ err }, 'Error parsing vulnerability alert');
    }
  }
  const alertPackageRules: PackageRule[] = [];
  config.remediations = {} as never;
  for (const [fileName, files] of Object.entries(combinedAlerts)) {
    for (const [datasource, dependencies] of Object.entries(files)) {
      for (const [depName, currentValues] of Object.entries(dependencies)) {
        for (const [matchCurrentVersion, val] of Object.entries(
          currentValues
        )) {
          let prBodyNotes: string[] = [];
          try {
            prBodyNotes = ['### GitHub Vulnerability Alerts'].concat(
              val.advisories.map((advisory) => {
                let content = '#### ';
                let heading: string;
                if (advisory.identifiers.some((id) => id.type === 'CVE')) {
                  heading = advisory.identifiers
                    .filter((id) => id.type === 'CVE')
                    .map((id) => id.value)
                    .join(' / ');
                } else {
                  heading = advisory.identifiers
                    .map((id) => id.value)
                    .join(' / ');
                }
                if (advisory.references.length) {
                  heading = `[${heading}](${advisory.references[0].url})`;
                }
                content += heading;
                content += '\n\n';

                content += sanitizeMarkdown(advisory.description);
                return content;
              })
            );
          } catch (err) /* istanbul ignore next */ {
            logger.warn({ err }, 'Error generating vulnerability PR notes');
          }
          const allowedVersions =
            datasource === PypiDatasource.id
              ? `==${val.firstPatchedVersion}`
              : val.firstPatchedVersion;
          let matchRule: PackageRule = {
            matchDatasources: [datasource],
            matchPackageNames: [depName],
            matchCurrentVersion,
            matchFiles: [fileName],
          };
          const supportedRemediationFileTypes = ['package-lock.json'];
          if (
            config.transitiveRemediation &&
            supportedRemediationFileTypes.includes(val.fileType)
          ) {
            config.remediations[fileName] ||= [];
            const currentVersion = matchCurrentVersion.replace('=', '').trim();
            const newVersion = allowedVersions;
            const remediation = {
              datasource,
              depName,
              currentVersion,
              newVersion,
              prBodyNotes,
            };
            config.remediations[fileName].push(remediation);
            // Disable the package rule as all vulnerabilities will be remediated via the lock file
            matchRule.enabled = false;
          } else {
            // Remediate only direct dependencies
            matchRule = {
              ...matchRule,
              allowedVersions,
              prBodyNotes,
              isVulnerabilityAlert: true,
              force: {
                ...config.vulnerabilityAlerts,
              },
            };
            // istanbul ignore if
            if (
              config.transitiveRemediation &&
              matchRule.matchFiles?.[0] === 'package.json'
            ) {
              matchRule.force.rangeStrategy = 'replace';
            }
          }
          alertPackageRules.push(matchRule);
        }
      }
    }
  }
  logger.debug({ alertPackageRules }, 'alert package rules');
  config.packageRules = (config.packageRules || []).concat(alertPackageRules);
  return config;
}
