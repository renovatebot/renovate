const versioning = require('../../../versioning');

module.exports = {
  detectVulnerabilityAlerts,
};

async function detectVulnerabilityAlerts(input) {
  if (!(input && input.vulnerabilityAlerts)) {
    return input;
  }
  if (input.vulnerabilityAlerts.enabled === false) {
    logger.debug('Vulnerability alerts are disabled');
    return input;
  }
  const alerts = await platform.getVulnerabilityAlerts();
  if (!alerts.length) {
    logger.debug('No vulnerability alerts found');
    if (input.vulnerabilityAlertsOnly) {
      throw new Error('no-vulnerability-alerts');
    }
    return input;
  }
  const config = { ...input };
  const combinedAlerts = {};
  for (const alert of alerts) {
    try {
      if (alert.dismissReason) {
        continue; // eslint-disable-line no-continue
      }
      const managerMapping = {
        MAVEN: 'maven',
        NPM: 'npm',
        NUGET: 'nuget',
        PIP: 'pip_requirements',
        RUBYGEMS: 'bundler',
      };
      const manager =
        managerMapping[alert.securityVulnerability.package.ecosystem];
      if (!combinedAlerts[manager]) {
        combinedAlerts[manager] = {};
      }
      const depName = alert.securityVulnerability.package.name;
      if (!combinedAlerts[manager][depName]) {
        combinedAlerts[manager][depName] = {
          advisories: [],
          fileNames: [],
        };
      }
      combinedAlerts[manager][depName].advisories.push(alert.securityAdvisory);
      const fileName = alert.vulnerableManifestFilename;
      if (!combinedAlerts[manager][depName].fileNames.includes(fileName)) {
        combinedAlerts[manager][depName].fileNames.push(fileName);
      }
      const firstPatchedVersion =
        alert.securityVulnerability.firstPatchedVersion.identifier;
      const versionSchemes = {
        maven: 'maven',
        npm: 'npm',
        nuget: 'semver',
        pip_requirements: 'pep440',
        rubygems: 'ruby',
      };
      const versionScheme = versioning.get(versionSchemes[manager]);
      if (versionScheme.isVersion(firstPatchedVersion)) {
        if (combinedAlerts[manager][depName].firstPatchedVersion) {
          if (
            versionScheme.isGreaterThan(
              firstPatchedVersion,
              combinedAlerts[manager][depName].firstPatchedVersion
            )
          ) {
            combinedAlerts[manager][
              depName
            ].firstPatchedVersion = firstPatchedVersion;
          }
        } else {
          combinedAlerts[manager][
            depName
          ].firstPatchedVersion = firstPatchedVersion;
        }
      } else {
        logger.info('Invalid firstPatchedVersion: ' + firstPatchedVersion);
      }
    } catch (err) {
      logger.warn({ err }, 'Error parsing vulnerability alert');
    }
  }
  const alertPackageRules = [];
  for (const [manager, dependencies] of Object.entries(combinedAlerts)) {
    for (const [depName, val] of Object.entries(dependencies)) {
      let prBodyNotes = [];
      try {
        prBodyNotes = ['### GitHub Vulnerability Alerts'].concat(
          val.advisories.map(advisory => {
            let content = '#### ';
            let heading;
            if (advisory.identifiers.some(id => id.type === 'CVE')) {
              heading = advisory.identifiers
                .filter(id => id.type === 'CVE')
                .map(id => id.value)
                .join(' / ');
            } else {
              heading = advisory.identifiers.map(id => id.value).join(' / ');
            }
            if (advisory.references.length) {
              heading = `[${heading}](${advisory.references[0].url})`;
            }
            content += heading;
            content += '\n\n';
            content += advisory.description;
            return content;
          })
        );
      } catch (err) /* istanbul ignore next */ {
        logger.warn({ err }, 'Error generating vulnerability PR notes');
      }
      const matchRule = {
        managers: [manager],
        packageNames: [depName],
        matchCurrentVersion: `< ${val.firstPatchedVersion}`,
        prBodyNotes,
        force: {
          ...config.vulnerabilityAlerts,
          vulnerabilityAlert: true,
          branchTopic: `${manager}-${depName}-vulnerability`,
        },
      };
      alertPackageRules.push(matchRule);
      const allowedRule = JSON.parse(JSON.stringify(matchRule));
      delete allowedRule.matchCurrentVersion;
      delete allowedRule.force;
      if (manager === 'npm') {
        allowedRule.allowedVersions = `^${val.firstPatchedVersion}`;
      } else {
        allowedRule.allowedVersions = `>= ${val.firstPatchedVersion}`;
      }
      alertPackageRules.push(allowedRule);
    }
  }
  config.packageRules = (config.packageRules || []).concat(alertPackageRules);
  return config;
}
