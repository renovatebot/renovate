let config;
beforeEach(() => {
  jest.resetAllMocks();
  config = require('../../../_fixtures/config');
});

const {
  detectVulnerabilityAlerts,
} = require('../../../../lib/workers/repository/init/vulnerability');

describe('workers/repository/init/vulnerability', () => {
  describe('detectVulnerabilityAlerts()', () => {
    it('returns if alerts are disabled', async () => {
      config.vulnerabilityAlerts.enabled = false;
      expect(await detectVulnerabilityAlerts(config)).toEqual(config);
    });
    it('returns if no alerts', async () => {
      delete config.vulnerabilityAlerts.enabled;
      platform.getVulnerabilityAlerts.mockReturnValue([]);
      expect(await detectVulnerabilityAlerts(config)).toEqual(config);
    });
    it('throws if no alerts and vulnerabilityAlertsOnly', async () => {
      config.vulnerabilityAlertsOnly = true;
      platform.getVulnerabilityAlerts.mockReturnValue([]);
      await expect(detectVulnerabilityAlerts(config)).rejects.toThrow(
        /no-vulnerability-alerts/
      );
    });
    it('returns alerts', async () => {
      delete config.vulnerabilityAlerts.enabled;
      platform.getVulnerabilityAlerts.mockReturnValue([
        {},
        {
          packageName: 'some-package',
          fixedIn: '1.1.0',
        },
        {},
      ]);
      const res = await detectVulnerabilityAlerts(config);
      expect(res.packageRules).toMatchSnapshot();
      expect(res.packageRules).toHaveLength(1);
    });
  });
});
