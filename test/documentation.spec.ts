/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */
import fs from 'node:fs';
import is from '@sindresorhus/is';
import { getOptions } from '../lib/config/options';

declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace jest {
    type ContainsOption<T> = T extends ArrayLike<unknown> ? T[number] : unknown;

    interface Matchers<R> {
      /**
       * only available in `test/website-docs.spec.js`
       * @param arg Value which current values should contain
       */
      toContainOption(arg: ContainsOption<R>): void;
    }
  }
}

const options = getOptions();

describe('documentation', () => {
  describe('website-documentation', () => {
    describe('configuration-options', () => {
      const doc = fs.readFileSync(
        'docs/usage/configuration-options.md',
        'utf8'
      );

      const headers = doc
        .match(/\n## (.*?)\n/g)
        ?.map((match) => match.substring(4, match.length - 1));

      const expectedOptions = options
        .filter((option) => !option.globalOnly)
        .filter((option) => !option.parent)
        .filter((option) => !option.autogenerated)
        .map((option) => option.name)
        .sort();

      it('has doc headers sorted alphabetically', () => {
        expect(headers).toEqual([...headers!].sort());
      });

      it('has headers for every required option', () => {
        expect(headers).toEqual(expectedOptions);
      });

      const subHeaders = doc
        .match(/\n### (.*?)\n/g)
        ?.map((match) => match.substring(5, match.length - 1));
      subHeaders!.sort();
      const expectedSubOptions = options
        .filter((option) => option.stage !== 'global')
        .filter((option) => !option.globalOnly)
        .filter((option) => option.parent)
        .map((option) => option.name)
        .sort();
      expectedSubOptions.sort();

      it('has headers for every required sub-option', () => {
        expect(subHeaders).toEqual(expectedSubOptions);
      });
    });

    describe('self-hosted-configuration', () => {
      const doc = fs.readFileSync(
        'docs/usage/self-hosted-configuration.md',
        'utf8'
      );

      const headers = doc
        .match(/\n## (.*?)\n/g)
        ?.map((match) => match.substring(4, match.length - 1));

      const expectedOptions = options
        .filter((option) => !!option.globalOnly)
        .map((option) => option.name)
        .sort();

      it('has headers sorted alphabetically', () => {
        expect(headers).toEqual([...headers!].sort());
      });

      it('has headers for every required option', () => {
        expect(headers).toEqual(expectedOptions);
      });
    });

    describe('unrelated', () => {
      // Checking relatedOptions field in options
      const relatedOptionsMatrix = options
        .map((option) => option.relatedOptions)
        .filter(is.truthy)
        .sort();

      let relatedOptions = ([] as string[]).concat(...relatedOptionsMatrix!); // Converts the matrix to an 1D array
      relatedOptions = [...new Set(relatedOptions)]; // Makes all options unique

      /*
      Matcher which checks if the argument is within the received array (or string)
      on an error, it throws a custom message.
      */
      expect.extend({
        toContainOption<T extends string>(received: T[], argument: T) {
          if (received.includes(argument)) {
            return {
              message: (): string =>
                `Option "${argument}" should be within options`,
              pass: true,
            };
          }
          return {
            message: (): string =>
              `Option "${argument}" doesn't exist within options`,
            pass: false,
          };
        },
      });

      const allOptionNames = options.map((option) => option.name).sort();

      // Lists through each option in the relatedOptions array to be able to locate the exact element which causes error, in case of one
      it('has valid relateOptions values', () => {
        relatedOptions.forEach((relOption) => {
          expect(allOptionNames).toContainOption(relOption);
        });
      });
    });
  });
});
